import numpy as np
from scipy.spatial import cKDTree
from config import y_min, y_max, D, k, phi_0, particle_radius, E_field


def compute_nearest_neighbor_distances_by_y_bin(positions, num_bins=300, bin_chunk=10, max_neighbors=5000):
    """
    Computes the average, minimum, and maximum distance to the nearest neighbor in y-axis bins.
    Useful for understanding particle crowding and spatial variation.
    """
    y_bins = np.linspace(y_min, y_max, num_bins + 1)
    bin_centers = 0.5 * (y_bins[:-1] + y_bins[1:])

    avg_distances = np.zeros(num_bins)
    min_distances = np.zeros(num_bins)
    max_distances = np.zeros(num_bins)
    counts = np.zeros(num_bins)

    for i in range(0, num_bins, bin_chunk):
        chunk_end = min(i + bin_chunk, num_bins)
        y_start = y_bins[i]
        y_end = y_bins[chunk_end]

        chunk_mask = (positions[:, 1] >= y_start) & (positions[:, 1] < y_end)
        chunk_positions = positions[chunk_mask]

        if len(chunk_positions) == 0:
            continue

        for j in range(i, chunk_end):
            y0, y1 = y_bins[j], y_bins[j + 1]
            bin_mask = (chunk_positions[:, 1] >= y0) & (chunk_positions[:, 1] < y1)
            bin_positions = chunk_positions[bin_mask]
            counts[j] = len(bin_positions)

            if len(bin_positions) < 2:
                avg_distances[j] = min_distances[j] = max_distances[j] = np.nan
                continue

            if len(bin_positions) > max_neighbors:
                bin_positions = bin_positions[np.random.choice(len(bin_positions), max_neighbors, replace=False)]

            tree = cKDTree(bin_positions)
            dists, _ = tree.query(bin_positions, k=2)  # k=2 to exclude self
            nearest_dists = dists[:, 1]

            avg_distances[j] = np.mean(nearest_dists)
            min_distances[j] = np.min(nearest_dists)
            max_distances[j] = np.max(nearest_dists)

    return bin_centers, avg_distances, min_distances, max_distances, counts


def compute_stress(positions, charges, surface_area, num_bins=300):
    """
    Computes stress (force per unit area) generated by external electric field along the x-axis.
    """
    y_bins = np.linspace(y_min, y_max, num_bins)
    stress_distribution = np.zeros(len(y_bins) - 1)

    for i in range(len(y_bins) - 1):
        indices = (positions[:, 1] >= y_bins[i]) & (positions[:, 1] < y_bins[i + 1])
        if np.any(indices):
            total_force = np.sum(charges[indices] * E_field[0])  # E-field in x-direction
            stress_distribution[i] = total_force / surface_area

    return y_bins[:-1], stress_distribution


def P(h):
    """
    Screened electrostatic repulsion model using the Debye–Hückel approximation.
    Used in pairwise force calculations.
    """
    x = k * h / 2
    if x > 350:
        return 0.0
    elif x > 50:
        denom = 0.25 * np.exp(2 * x)
    else:
        denom = np.cosh(x)**2
    return (D * k**2 * phi_0**2) / (8 * np.pi * denom)


def compute_stress_by_repulsion_chunked(positions, particle_radius, surface_area, x_bins, y_bins, bin_chunk=10):
    """
    Computes local stress along the y-axis caused by repulsive electrostatic interactions between particles.
    Uses a KD-Tree for neighbor search within a defined radius.
    """
    stress_y_distribution = np.zeros(len(y_bins) - 1)

    for i in range(0, len(y_bins) - 1, bin_chunk):
        y_start = y_bins[i]
        y_end = y_bins[min(i + bin_chunk + 1, len(y_bins) - 1)]

        chunk_mask = (positions[:, 1] >= y_start) & (positions[:, 1] < y_end)
        chunk_positions = positions[chunk_mask]

        if len(chunk_positions) == 0:
            continue

        tree = cKDTree(chunk_positions)
        repulsion_forces_y = np.zeros(len(chunk_positions))

        for a in range(len(chunk_positions)):
            neighbors = tree.query_ball_point(chunk_positions[a], r=4 * particle_radius)
            for b in neighbors:
                if a >= b:
                    continue
                delta = chunk_positions[a] - chunk_positions[b]
                dist = np.linalg.norm(delta)
                if dist == 0:
                    continue

                x = k * dist / 2
                if x > 50:
                    denom = 0.25 * np.exp(2 * x)
                else:
                    denom = np.cosh(x)**2

                force_mag = (D * k**2 * phi_0**2) / (8 * np.pi * denom)
                force_mag *= np.pi * particle_radius

                force_vec = force_mag * (delta / dist)
                repulsion_forces_y[a] += force_vec[1]
                repulsion_forces_y[b] -= force_vec[1]

        for j in range(bin_chunk):
            bin_index = i + j
            if bin_index >= len(y_bins) - 1:
                break
            y0, y1 = y_bins[bin_index], y_bins[bin_index + 1]
            in_y_bin = (chunk_positions[:, 1] >= y0) & (chunk_positions[:, 1] < y1)

            if np.any(in_y_bin):
                total_force_y = np.sum(np.abs(repulsion_forces_y[in_y_bin]))
                stress_y_distribution[bin_index] = total_force_y / surface_area

    return stress_y_distribution